diff -ruN linux/arch/x86/include/asm/kroom.h linux-v1/arch/x86/include/asm/kroom.h
--- linux/arch/x86/include/asm/kroom.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-v1/arch/x86/include/asm/kroom.h	2023-10-10 16:01:15.742230960 +0300
@@ -0,0 +1,12 @@
+#ifndef _ASM_X86_KROOM_H
+#ifdef CONFIG_KROOM
+
+#include <linux/mm_types.h>
+
+struct sampler_data;
+
+void kroom_poison(struct mm_struct *mm);
+void kroom_unpoison(struct mm_struct *mm);
+
+#endif /* CONFIG_KROOM */
+#endif /* _ASM_X86_KROOM_H */
diff -ruN linux/arch/x86/include/asm/page_64_types.h linux-v1/arch/x86/include/asm/page_64_types.h
--- linux/arch/x86/include/asm/page_64_types.h	2022-03-23 17:39:00.242183791 +0200
+++ linux-v1/arch/x86/include/asm/page_64_types.h	2023-02-08 13:23:39.824091737 +0200
@@ -94,8 +94,15 @@
 #define TASK_SIZE_OF(child)	((test_tsk_thread_flag(child, TIF_ADDR32)) ? \
 					IA32_PAGE_OFFSET : TASK_SIZE_MAX)
 
+#ifdef CONFIG_KROOM
+#define __VIRTUAL_SAMPLED_MIN	(((_AC(1,UL) << (__VIRTUAL_MASK_SHIFT))) - (_AC(1,UL) << (__VIRTUAL_MASK_SHIFT - 8)))
+#define __VIRTUAL_UNSAMPLED_MAX	(__VIRTUAL_SAMPLED_MIN - PAGE_SIZE)
+#define STACK_TOP		((TASK_SIZE_LOW > __VIRTUAL_UNSAMPLED_MAX)?__VIRTUAL_UNSAMPLED_MAX:TASK_SIZE_LOW)
+#define STACK_TOP_MAX		((TASK_SIZE_MAX > __VIRTUAL_UNSAMPLED_MAX)?__VIRTUAL_UNSAMPLED_MAX:TASK_SIZE_MAX)
+#else
 #define STACK_TOP		TASK_SIZE_LOW
 #define STACK_TOP_MAX		TASK_SIZE_MAX
+#endif /* CONFIG_KROOM */
 
 /*
  * In spite of the name, KERNEL_IMAGE_SIZE is a limit on the maximum virtual
diff -ruN linux/arch/x86/include/asm/pgtable.h linux-v1/arch/x86/include/asm/pgtable.h
--- linux/arch/x86/include/asm/pgtable.h	2022-03-23 17:39:00.242183791 +0200
+++ linux-v1/arch/x86/include/asm/pgtable.h	2023-10-13 14:54:30.828727024 +0300
@@ -903,6 +903,13 @@
 
 static inline int p4d_present(p4d_t p4d)
 {
+	#ifdef CONFIG_KROOM
+	#if CONFIG_PGTABLE_LEVELS > 4
+	return p4d_flags(p4d) & (_PAGE_PRESENT | _PAGE_USER);
+	#else
+	return p4d_flags(p4d) & (_PAGE_PRESENT | _PAGE_USER);
+	#endif	/* CONFIG_PGTABLE_LEVELS > 4 */
+	#endif /* CONFIG_KROOM */
 	return p4d_flags(p4d) & _PAGE_PRESENT;
 }
 
@@ -926,6 +933,28 @@
 
 	return (p4d_flags(p4d) & ~ignore_flags) != 0;
 }
+
+#ifdef CONFIG_KROOM
+static inline p4d_t p4d_sample_poison(p4d_t p4d)
+{
+	return native_make_p4d(native_p4d_val(p4d) & (~_PAGE_PRESENT));
+}
+
+static inline p4d_t p4d_sample_unpoison(p4d_t p4d)
+{
+	return native_make_p4d(native_p4d_val(p4d) | _PAGE_PRESENT);
+}
+
+static inline int p4d_sample_poisoned(p4d_t p4d)
+{
+	return ((p4d_flags(p4d) & (_PAGE_PRESENT | _PAGE_USER)) == _PAGE_USER);
+}
+
+static inline int p4d_sample_poisonable(p4d_t p4d)
+{
+	return ((p4d_flags(p4d) & (_PAGE_PRESENT | _PAGE_USER)) == (_PAGE_PRESENT | _PAGE_USER));
+}
+#endif /* CONFIG_KROOM */
 #endif  /* CONFIG_PGTABLE_LEVELS > 3 */
 
 static inline unsigned long p4d_index(unsigned long address)
diff -ruN linux/arch/x86/include/uapi/asm/mman.h linux-v1/arch/x86/include/uapi/asm/mman.h
--- linux/arch/x86/include/uapi/asm/mman.h	2022-03-23 17:39:00.252183833 +0200
+++ linux-v1/arch/x86/include/uapi/asm/mman.h	2022-03-23 18:19:41.523206450 +0200
@@ -4,6 +4,8 @@
 
 #define MAP_32BIT	0x40		/* only give out 32bit addresses */
 
+#define MAP_SAMPLED	0x80		/* make the mapping available for the profiling sampler */
+
 #ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
 /*
  * Take the 4 protection key bits out of the vma->vm_flags
diff -ruN linux/arch/x86/Kconfig linux-v1/arch/x86/Kconfig
--- linux/arch/x86/Kconfig	2022-03-23 17:39:00.232183750 +0200
+++ linux-v1/arch/x86/Kconfig	2023-02-08 13:20:28.003221045 +0200
@@ -1851,6 +1851,17 @@
 
 	  If unsure, say y.
 
+config KROOM
+	prompt "Pagefault sampling based profiler (KROOM)"
+	def_bool n
+	# Note: only available in 64-bit mode
+	depends on X86_64
+	help
+	  Enable sample based monitoring of memory acceses for profiling reasons.
+	  It uses page faults in order to work. Necessary for SHAMBLES
+
+	  If unsure, say n.
+
 choice
 	prompt "TSX enable mode"
 	depends on CPU_SUP_INTEL
diff -ruN linux/arch/x86/kernel/sys_x86_64.c linux-v1/arch/x86/kernel/sys_x86_64.c
--- linux/arch/x86/kernel/sys_x86_64.c	2022-03-23 17:39:00.262183874 +0200
+++ linux-v1/arch/x86/kernel/sys_x86_64.c	2023-10-13 16:45:53.473428799 +0300
@@ -114,6 +114,22 @@
 		}
 		return;
 	}
+	
+	#ifdef CONFIG_KROOM
+	if (!in_32bit_syscall()) {
+		if(flags & MAP_SAMPLED) {
+			*begin = __VIRTUAL_SAMPLED_MIN;
+			*end = task_size_64bit(1);
+		}else{
+			*begin	= get_mmap_base(1);
+			*end = task_size_64bit(addr > DEFAULT_MAP_WINDOW);
+			if(*end > __VIRTUAL_UNSAMPLED_MAX){
+				*end = __VIRTUAL_UNSAMPLED_MAX;
+			}
+		}
+		return;
+	}
+	#endif /* CONFIG_KROOM */
 
 	*begin	= get_mmap_base(1);
 	if (in_32bit_syscall())
@@ -138,6 +154,21 @@
 
 	if (len > end)
 		return -ENOMEM;
+	
+	#ifdef CONFIG_KROOM
+	if (addr) {
+		addr = PAGE_ALIGN(addr);
+		if(flags & MAP_SAMPLED) {
+			if(addr < __VIRTUAL_SAMPLED_MIN){
+				addr = (unsigned long)NULL;
+			}
+		}else{
+			if(addr + len > __VIRTUAL_UNSAMPLED_MAX){
+				addr = (unsigned long)NULL;
+			}
+		}
+	}
+	#endif /* CONFIG_KROOM */
 
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
@@ -185,6 +216,17 @@
 	/* requesting a specific address */
 	if (addr) {
 		addr &= PAGE_MASK;
+		#ifdef CONFIG_KROOM
+		if(flags & MAP_SAMPLED) {
+			if(addr < __VIRTUAL_SAMPLED_MIN){
+				goto get_unmapped_area;
+			}
+		}else{
+			if(addr + len > __VIRTUAL_UNSAMPLED_MAX){
+				goto get_unmapped_area;
+			}
+		}
+		#endif /* CONFIG_KROOM */
 		if (!mmap_address_hint_valid(addr, len))
 			goto get_unmapped_area;
 
@@ -209,8 +251,22 @@
 	if (addr > DEFAULT_MAP_WINDOW && !in_32bit_syscall())
 		info.high_limit += TASK_SIZE_MAX - DEFAULT_MAP_WINDOW;
 
-	info.align_mask = 0;
-	info.align_offset = pgoff << PAGE_SHIFT;
+	#ifdef CONFIG_KROOM
+        if(flags & MAP_SAMPLED) {
+                info.low_limit = __VIRTUAL_SAMPLED_MIN;
+                info.high_limit = task_size_64bit(1);
+        }else{
+                info.low_limit = PAGE_SIZE;
+                info.high_limit = get_mmap_base(0);
+                if(info.high_limit > __VIRTUAL_UNSAMPLED_MAX){
+                        info.high_limit = __VIRTUAL_UNSAMPLED_MAX;
+                }
+        }
+        #else
+        info.low_limit = PAGE_SIZE;
+        info.high_limit = get_mmap_base(0);
+        #endif /* CONFIG_KROOM */
+
 	if (filp) {
 		info.align_mask = get_align_mask();
 		info.align_offset += get_align_bits();
diff -ruN linux/arch/x86/mm/kroom.c linux-v1/arch/x86/mm/kroom.c
--- linux/arch/x86/mm/kroom.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-v1/arch/x86/mm/kroom.c	2023-10-17 10:30:54.387195827 +0300
@@ -0,0 +1,46 @@
+#include <asm/kroom.h>
+#include <asm/tlbflush.h>
+#include <linux/pgtable.h>
+
+void kroom_poison(struct mm_struct *mm){
+	//struct mmu_gather tlb;
+	//tlb_gather_mmu(&tlb, mm);
+	pgd_t *pgd;
+	p4d_t *p4d;
+	#if CONFIG_PGTABLE_LEVELS > 4
+	if(!pgtable_l5_enabled()){
+		pgd = pgd_offset(mm, 0x7f8000000000);
+		p4d = p4d_offset(pgd, 0x7f8000000000);
+	}else{
+		//todo
+	}
+	#else
+	pgd = pgd_offset(mm, 0x7f8000000000);
+	p4d = p4d_offset(pgd, 0x7f8000000000);
+	#endif	/* CONFIG_PGTABLE_LEVELS > 4 */
+	if(p4d_sample_poisonable(*p4d)){
+		set_p4d(p4d, p4d_sample_poison(*p4d));
+		flush_tlb_mm(mm);
+		//tlb_flush(&tlb);
+	}
+	//tlb_finish_mmu(&tlb);
+	//printk(KERN_INFO "Timer hit\n");
+}
+
+void kroom_unpoison(struct mm_struct *mm){
+	pgd_t *pgd;
+	p4d_t *p4d;
+	#if CONFIG_PGTABLE_LEVELS > 4
+	if(!pgtable_l5_enabled()){
+		pgd = pgd_offset(mm, 0x7f8000000000);
+		p4d = p4d_offset(pgd, 0x7f8000000000);
+	}else{
+		//todo
+	}
+	#else
+	pgd = pgd_offset(mm, 0x7f8000000000);
+	p4d = p4d_offset(pgd, 0x7f8000000000);
+	#endif	/* CONFIG_PGTABLE_LEVELS > 4 */
+	set_p4d(p4d, p4d_sample_unpoison(*p4d));
+	//printk(KERN_INFO "unpoisoned something\n");
+}
diff -ruN linux/arch/x86/mm/Makefile linux-v1/arch/x86/mm/Makefile
--- linux/arch/x86/mm/Makefile	2022-03-23 17:39:00.272183916 +0200
+++ linux-v1/arch/x86/mm/Makefile	2023-10-11 10:11:44.353822519 +0300
@@ -55,3 +55,5 @@
 obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt.o
 obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_identity.o
 obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_boot.o
+
+obj-$(CONFIG_KROOM)	+= kroom.o
diff -ruN linux/include/linux/kroom.h linux-v1/include/linux/kroom.h
--- linux/include/linux/kroom.h	1970-01-01 02:00:00.000000000 +0200
+++ linux-v1/include/linux/kroom.h	2023-10-13 13:37:35.108187023 +0300
@@ -0,0 +1,12 @@
+#ifndef _LINUX_KROOM_H
+#ifdef CONFIG_KROOM
+
+#include <linux/mm_types.h>
+
+struct kroom_data;
+extern bool kroom_enabled;
+
+void kroom_report(struct mm_struct *mm, void *addr, void *pc);
+
+#endif /* CONFIG_KROOM */
+#endif /* _LINUX_KROOM_H */
diff -ruN linux/include/linux/mm_types.h linux-v1/include/linux/mm_types.h
--- linux/include/linux/mm_types.h	2022-03-23 17:39:02.522193183 +0200
+++ linux-v1/include/linux/mm_types.h	2023-10-13 13:54:15.906320828 +0300
@@ -16,6 +16,9 @@
 #include <linux/workqueue.h>
 #include <linux/seqlock.h>
 
+#include <linux/hrtimer.h>
+#ifdef CONFIG_KROOM
+#endif
 #include <asm/mmu.h>
 
 #ifndef AT_VECTOR_SIZE_ARCH
@@ -577,6 +580,10 @@
 #endif
 	} __randomize_layout;
 
+#ifdef CONFIG_KROOM
+	void *kroom_handle;
+#endif
+
 	/*
 	 * The mm_cpumask needs to be at the end of mm_struct, because it
 	 * is dynamically sized based on nr_cpu_ids.
diff -ruN linux/mm/kroom.c linux-v1/mm/kroom.c
--- linux/mm/kroom.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-v1/mm/kroom.c	2023-10-13 16:41:54.601757637 +0300
@@ -0,0 +1,165 @@
+#include <asm/kroom.h>
+#include <linux/kroom.h>
+#include <linux/hrtimer.h>
+
+#include <linux/debugfs.h>
+#include <linux/fs.h>
+
+#define TIMER_SEC 0
+#define TIMER_NSEC 100000
+
+static ktime_t kt;
+bool kroom_enabled;
+
+struct kroom_handle{
+	struct mm_struct	*mm;
+	struct hrtimer		timer;
+	struct mutex		lock;
+	struct semaphore	wait_sem;
+	void 				*addr, *pc;
+};
+
+static enum hrtimer_restart kroom_timer_hander(struct hrtimer *timer)
+{
+	struct kroom_handle *handle;
+	struct mm_struct *mm;
+	handle = container_of(timer, struct kroom_handle, timer);
+	mm = handle->mm;
+
+	/*I hate doing this, but it is not entirely my fault...*/
+	if(mmap_write_trylock(mm)){
+		kroom_poison(mm);
+		mmap_write_unlock(mm);
+	}
+    hrtimer_forward(timer,timer->base->get_time(),kt);
+    return HRTIMER_RESTART;
+}
+
+int kroom_activate(struct kroom_handle *handle){
+	void *useless = NULL;
+	handle->mm = current->mm;
+	//printk(KERN_INFO "Activating sampler for mmstruct %p\n", handle->mm);
+	if(!__atomic_compare_exchange_n(&handle->mm->kroom_handle, &useless, handle, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED)){
+		return -ENOMEM;
+	}
+	mmgrab(handle->mm);
+	//mm->sample_data = (void *)kroom_data_create();
+	mutex_init(&handle->lock);
+	sema_init(&handle->wait_sem, 0);
+	handle->addr = NULL;
+	handle->pc = NULL;
+	hrtimer_init(&handle->timer,CLOCK_MONOTONIC,HRTIMER_MODE_REL_SOFT);
+	handle->timer.function = kroom_timer_hander;
+	hrtimer_start(&handle->timer,kt,HRTIMER_MODE_REL_SOFT);
+	return 0;
+}
+
+void kroom_deactivate(struct kroom_handle *handle){
+	//printk(KERN_INFO "Deactivating sampler for mmstruct %p\n", handle->mm);
+	hrtimer_cancel(&handle->timer);
+	kroom_unpoison(handle->mm);
+	__atomic_store_n(&handle->mm->kroom_handle, NULL, __ATOMIC_RELAXED);
+	mmdrop(handle->mm);
+}
+
+void kroom_report(struct mm_struct *mm, void *addr, void *pc){
+	struct kroom_handle *handle;
+	handle = (struct kroom_handle *)(mm->kroom_handle);
+	mutex_lock(&handle->lock);
+
+	/*Hack alert make sure that the any unread old value is discarded*/
+	if(down_trylock(&handle->wait_sem));
+
+	handle->addr = addr;
+	handle->pc = pc;
+	up(&handle->wait_sem);
+	mutex_unlock(&handle->lock);
+}
+
+/*
+ * Debugfs interface
+ */
+
+/*
+ * To user comunication
+ */
+
+static int sample_open(struct inode *node, struct file *filp){
+	struct kroom_handle *handle;
+	int err;
+	if(!kroom_enabled){
+		return -EACCES;
+	}
+	handle = kmalloc(GFP_KERNEL, sizeof(struct kroom_handle));
+	err = kroom_activate(handle);
+	if(err){
+		kfree(handle);
+		return err;
+	}
+	filp->private_data = handle;
+	return 0;
+}
+
+static int sample_release(struct inode *node, struct file *filp){
+	struct kroom_handle *handle;
+	handle = filp->private_data;
+	kroom_deactivate(handle);
+	kfree(handle);
+	return 0;
+}
+
+static ssize_t sample_read(struct file *filp, char __user *buffer, size_t size, loff_t *offset){
+	struct kroom_handle *handle;
+	if(size != 16){
+		return -EINVAL;
+	}
+	handle = filp->private_data;
+
+	/*Fork maybe?*/
+	if(handle->mm != current->mm){
+		return -EPERM;
+	}
+	if(down_interruptible(&handle->wait_sem)){
+		return -ERESTARTSYS;
+	}
+	mutex_lock(&handle->lock);
+
+	/*Hack alert make sure that you do not read a duplicate value*/
+	if(down_trylock(&handle->wait_sem));
+
+	if(copy_to_user(buffer, &handle->addr, 8)){
+		mutex_unlock(&handle->lock);
+		return -EFAULT;
+	}
+	if(copy_to_user(buffer+8, &handle->pc, 8)){
+		mutex_unlock(&handle->lock);
+		return -EFAULT;
+	}
+
+	mutex_unlock(&handle->lock);
+	return 16;
+}
+
+static struct file_operations fops = {
+	.owner			= THIS_MODULE,
+	.open			= sample_open,
+	.release		= sample_release,
+	.read			= sample_read
+};
+
+/*
+ * init
+ */
+static int __init kroom_init(void){
+	static struct dentry *dir = 0;
+
+	printk(KERN_INFO "Initing kroom\n");
+	kt = ktime_set(TIMER_SEC, TIMER_NSEC);
+	dir = debugfs_create_dir("sampler", NULL);
+	debugfs_create_x64("interval_ns", S_IRUGO|S_IWUGO, dir, &kt);
+	debugfs_create_file("samples", S_IRUGO|S_IWUGO, dir, NULL, &fops);
+	debugfs_create_bool("enabled", S_IRUGO|S_IWUGO, dir, &kroom_enabled);
+	return 0;
+}
+
+subsys_initcall(kroom_init);
diff -ruN linux/mm/Makefile linux-v1/mm/Makefile
--- linux/mm/Makefile	2022-03-23 17:39:02.742194089 +0200
+++ linux-v1/mm/Makefile	2023-10-11 11:10:28.669236223 +0300
@@ -66,6 +66,7 @@
 	obj-$(CONFIG_ADVISE_SYSCALLS)	+= madvise.o
 endif
 
+obj-$(CONFIG_KROOM) 	+= kroom.o
 obj-$(CONFIG_SWAP)	+= page_io.o swap_state.o swapfile.o swap_slots.o
 obj-$(CONFIG_FRONTSWAP)	+= frontswap.o
 obj-$(CONFIG_ZSWAP)	+= zswap.o
diff -ruN linux/mm/memory.c linux-v1/mm/memory.c
--- linux/mm/memory.c	2022-03-23 17:39:02.752194130 +0200
+++ linux-v1/mm/memory.c	2023-10-13 13:23:03.281856837 +0300
@@ -83,6 +83,11 @@
 #include <asm/tlb.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_KROOM
+#include <asm/kroom.h>
+#include <linux/kroom.h>
+#endif /* CONFIG_KROOM */
+
 #include "pgalloc-track.h"
 #include "internal.h"
 
@@ -4433,6 +4438,18 @@
 	vmf.pud = pud_alloc(mm, p4d, address);
 	if (!vmf.pud)
 		return VM_FAULT_OOM;
+	
+	#ifdef CONFIG_KROOM
+	if(p4d_sample_poisoned(*p4d)){
+		kroom_unpoison(mm);
+		kroom_report(mm, (void *)address, (void *)KSTK_EIP(current));
+		return VM_FAULT_NOPAGE;
+	}
+	#endif /* CONFIG_KROOM */	
+	
+	//if(address >= 0x7f8000000000LLU){
+	//	printk(KERN_INFO "Faulting in addr=0x%lx, pgd_index=0x%lx, pgd=%lx, p4d=%lx, pud=%lx\n", address, pgd_index(address), pgd, p4d, vmf.pud);
+	//}
 retry_pud:
 	if (pud_none(*vmf.pud) && __transparent_hugepage_enabled(vma)) {
 		ret = create_huge_pud(&vmf);
diff -ruN linux/mm/mmap.c linux-v1/mm/mmap.c
--- linux/mm/mmap.c	2022-03-23 17:39:02.752194130 +0200
+++ linux-v1/mm/mmap.c	2023-10-13 16:42:23.501956569 +0300
@@ -73,6 +73,10 @@
 int mmap_rnd_compat_bits __read_mostly = CONFIG_ARCH_MMAP_RND_COMPAT_BITS;
 #endif
 
+#ifdef CONFIG_KROOM
+#include <linux/kroom.h>
+#endif
+
 static bool ignore_rlimit_data;
 core_param(ignore_rlimit_data, ignore_rlimit_data, bool, 0644);
 
@@ -1477,6 +1481,12 @@
 	if (mlock_future_check(mm, vm_flags, len))
 		return -EAGAIN;
 
+	#ifdef CONFIG_KROOM
+	if((flags & MAP_SAMPLED) && !kroom_enabled){
+		return -EACCES;
+	}
+	#endif
+
 	if (file) {
 		struct inode *inode = file_inode(file);
 		unsigned long flags_mask;
diff -ruN linux/mm/pgtable-generic.c linux-v1/mm/pgtable-generic.c
--- linux/mm/pgtable-generic.c	2022-03-23 17:39:02.752194130 +0200
+++ linux-v1/mm/pgtable-generic.c	2022-03-23 17:42:33.813063427 +0200
@@ -27,6 +27,7 @@
 #ifndef __PAGETABLE_P4D_FOLDED
 void p4d_clear_bad(p4d_t *p4d)
 {
+	dump_stack();
 	p4d_ERROR(*p4d);
 	p4d_clear(p4d);
 }
